using KillaCore.Blazor.FileUpload.Services; // Namespace for your Security Service
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;

namespace KillaCore.Blazor.FileUpload.Controllers;

[ApiController]
[Route("api/uploads")]
public sealed class UploadsController(
    IWebHostEnvironment env,
    IFileUploadSecurityService securityService // 1. Inject Security
    ) : ControllerBase
{
    [AllowAnonymous] // We allow anonymous because we rely on the Token
    [HttpPost("temp")]
    [RequestSizeLimit(1024 * 1024 * 500)]
    public async Task<IActionResult> UploadTemp([FromForm] IFormFile file, CancellationToken ct)
    {
        // --- 1. SECURITY CHECK ---
        // If the header is missing or the token is invalid, reject immediately.
        if (!Request.Headers.TryGetValue("X-Upload-Token", out var tokenValues))
        {
            return Unauthorized("Missing upload token.");
        }

        // Explicitly convert StringValues to string
        var token = tokenValues.ToString();

        // Validate the token. We can pass "Anonymous" or a placeholder if we don't care about the specific UserID here, 
        // but the token MUST be valid and generated by our C# component.
        // Assuming your ValidateToken checks the user, or if you want to allow generic uploads:
        var userId = User.Identity?.Name ?? "Anonymous";
        if (!securityService.ValidateToken(token, userId, out _))
        {
            return Unauthorized("Invalid or expired token.");
        }

        // --- 2. VALIDATION ---
        if (file == null || file.Length == 0)
            return BadRequest("Empty file.");

        var tempRoot = Path.Combine(env.ContentRootPath, "App_Data", "temp-uploads");
        Directory.CreateDirectory(tempRoot);

        // Use random name to avoid exposing original file name
        var tempId = $"{Guid.NewGuid():N}_{Path.GetRandomFileName()}";
        var tempPath = Path.Combine(tempRoot, tempId);

        try
        {
            await using var fs = new FileStream(
                tempPath,
                FileMode.CreateNew,
                FileAccess.Write,
                FileShare.None,
                81920, // 80KB Buffer
                FileOptions.Asynchronous | FileOptions.SequentialScan);

            // --- 3. THE FIX: ACTUALLY COPY THE DATA ---
            await file.CopyToAsync(fs, ct);

            return Ok(new
            {
                // Return the full path so the C# component can find it easily
                tempPath,
                size = file.Length,
                contentType = file.ContentType
            });
        }
        catch (OperationCanceledException)
        {
            TryDelete(tempPath);
            // 499 Client Closed Request is appropriate for cancellation
            return StatusCode(499, "Upload cancelled");
        }
        catch (Exception ex)
        {
            TryDelete(tempPath);
            return Problem($"Upload failed: {ex.Message}");
        }
    }

    private static void TryDelete(string path)
    {
        try
        {
            if (System.IO.File.Exists(path))
                System.IO.File.Delete(path);
        }
        catch { /* Swallow cleanup errors */ }
    }
}